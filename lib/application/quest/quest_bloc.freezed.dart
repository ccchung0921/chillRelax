// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'quest_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$QuestEventTearOff {
  const _$QuestEventTearOff();

// ignore: unused_element
  DetectSetUp detectSetUp() {
    return const DetectSetUp();
  }
}

/// @nodoc
// ignore: unused_element
const $QuestEvent = _$QuestEventTearOff();

/// @nodoc
mixin _$QuestEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult detectSetUp(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult detectSetUp(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult detectSetUp(DetectSetUp value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult detectSetUp(DetectSetUp value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $QuestEventCopyWith<$Res> {
  factory $QuestEventCopyWith(
          QuestEvent value, $Res Function(QuestEvent) then) =
      _$QuestEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$QuestEventCopyWithImpl<$Res> implements $QuestEventCopyWith<$Res> {
  _$QuestEventCopyWithImpl(this._value, this._then);

  final QuestEvent _value;
  // ignore: unused_field
  final $Res Function(QuestEvent) _then;
}

/// @nodoc
abstract class $DetectSetUpCopyWith<$Res> {
  factory $DetectSetUpCopyWith(
          DetectSetUp value, $Res Function(DetectSetUp) then) =
      _$DetectSetUpCopyWithImpl<$Res>;
}

/// @nodoc
class _$DetectSetUpCopyWithImpl<$Res> extends _$QuestEventCopyWithImpl<$Res>
    implements $DetectSetUpCopyWith<$Res> {
  _$DetectSetUpCopyWithImpl(
      DetectSetUp _value, $Res Function(DetectSetUp) _then)
      : super(_value, (v) => _then(v as DetectSetUp));

  @override
  DetectSetUp get _value => super._value as DetectSetUp;
}

/// @nodoc
class _$DetectSetUp implements DetectSetUp {
  const _$DetectSetUp();

  @override
  String toString() {
    return 'QuestEvent.detectSetUp()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is DetectSetUp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult detectSetUp(),
  }) {
    assert(detectSetUp != null);
    return detectSetUp();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult detectSetUp(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (detectSetUp != null) {
      return detectSetUp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult detectSetUp(DetectSetUp value),
  }) {
    assert(detectSetUp != null);
    return detectSetUp(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult detectSetUp(DetectSetUp value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (detectSetUp != null) {
      return detectSetUp(this);
    }
    return orElse();
  }
}

abstract class DetectSetUp implements QuestEvent {
  const factory DetectSetUp() = _$DetectSetUp;
}

/// @nodoc
class _$QuestStateTearOff {
  const _$QuestStateTearOff();

// ignore: unused_element
  _Initial initial() {
    return const _Initial();
  }

// ignore: unused_element
  _SetUp setUp() {
    return const _SetUp();
  }

// ignore: unused_element
  _NotSetUp notSetUp() {
    return const _NotSetUp();
  }
}

/// @nodoc
// ignore: unused_element
const $QuestState = _$QuestStateTearOff();

/// @nodoc
mixin _$QuestState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult setUp(),
    @required TResult notSetUp(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult setUp(),
    TResult notSetUp(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult setUp(_SetUp value),
    @required TResult notSetUp(_NotSetUp value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult setUp(_SetUp value),
    TResult notSetUp(_NotSetUp value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $QuestStateCopyWith<$Res> {
  factory $QuestStateCopyWith(
          QuestState value, $Res Function(QuestState) then) =
      _$QuestStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$QuestStateCopyWithImpl<$Res> implements $QuestStateCopyWith<$Res> {
  _$QuestStateCopyWithImpl(this._value, this._then);

  final QuestState _value;
  // ignore: unused_field
  final $Res Function(QuestState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$QuestStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc
class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'QuestState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult setUp(),
    @required TResult notSetUp(),
  }) {
    assert(initial != null);
    assert(setUp != null);
    assert(notSetUp != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult setUp(),
    TResult notSetUp(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult setUp(_SetUp value),
    @required TResult notSetUp(_NotSetUp value),
  }) {
    assert(initial != null);
    assert(setUp != null);
    assert(notSetUp != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult setUp(_SetUp value),
    TResult notSetUp(_NotSetUp value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements QuestState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$SetUpCopyWith<$Res> {
  factory _$SetUpCopyWith(_SetUp value, $Res Function(_SetUp) then) =
      __$SetUpCopyWithImpl<$Res>;
}

/// @nodoc
class __$SetUpCopyWithImpl<$Res> extends _$QuestStateCopyWithImpl<$Res>
    implements _$SetUpCopyWith<$Res> {
  __$SetUpCopyWithImpl(_SetUp _value, $Res Function(_SetUp) _then)
      : super(_value, (v) => _then(v as _SetUp));

  @override
  _SetUp get _value => super._value as _SetUp;
}

/// @nodoc
class _$_SetUp implements _SetUp {
  const _$_SetUp();

  @override
  String toString() {
    return 'QuestState.setUp()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _SetUp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult setUp(),
    @required TResult notSetUp(),
  }) {
    assert(initial != null);
    assert(setUp != null);
    assert(notSetUp != null);
    return setUp();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult setUp(),
    TResult notSetUp(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (setUp != null) {
      return setUp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult setUp(_SetUp value),
    @required TResult notSetUp(_NotSetUp value),
  }) {
    assert(initial != null);
    assert(setUp != null);
    assert(notSetUp != null);
    return setUp(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult setUp(_SetUp value),
    TResult notSetUp(_NotSetUp value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (setUp != null) {
      return setUp(this);
    }
    return orElse();
  }
}

abstract class _SetUp implements QuestState {
  const factory _SetUp() = _$_SetUp;
}

/// @nodoc
abstract class _$NotSetUpCopyWith<$Res> {
  factory _$NotSetUpCopyWith(_NotSetUp value, $Res Function(_NotSetUp) then) =
      __$NotSetUpCopyWithImpl<$Res>;
}

/// @nodoc
class __$NotSetUpCopyWithImpl<$Res> extends _$QuestStateCopyWithImpl<$Res>
    implements _$NotSetUpCopyWith<$Res> {
  __$NotSetUpCopyWithImpl(_NotSetUp _value, $Res Function(_NotSetUp) _then)
      : super(_value, (v) => _then(v as _NotSetUp));

  @override
  _NotSetUp get _value => super._value as _NotSetUp;
}

/// @nodoc
class _$_NotSetUp implements _NotSetUp {
  const _$_NotSetUp();

  @override
  String toString() {
    return 'QuestState.notSetUp()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NotSetUp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult setUp(),
    @required TResult notSetUp(),
  }) {
    assert(initial != null);
    assert(setUp != null);
    assert(notSetUp != null);
    return notSetUp();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult setUp(),
    TResult notSetUp(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notSetUp != null) {
      return notSetUp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult setUp(_SetUp value),
    @required TResult notSetUp(_NotSetUp value),
  }) {
    assert(initial != null);
    assert(setUp != null);
    assert(notSetUp != null);
    return notSetUp(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult setUp(_SetUp value),
    TResult notSetUp(_NotSetUp value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notSetUp != null) {
      return notSetUp(this);
    }
    return orElse();
  }
}

abstract class _NotSetUp implements QuestState {
  const factory _NotSetUp() = _$_NotSetUp;
}
